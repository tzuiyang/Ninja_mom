<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mom Ninja Birthday</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle, #ffe6f2, #ffccee); /* Soft pink background */
            font-family: 'Arial', sans-serif;
            touch-action: none; /* Critical for swipe games */
            user-select: none;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #d63384;
            pointer-events: none;
            z-index: 10;
        }
        h1 {
            margin: 0;
            font-size: 24px;
            text-shadow: 2px 2px 0px white;
        }
        p {
            margin: 5px 0;
            font-size: 20px;
            font-weight: bold;
        }
        /* Added victory-screen to this list so it shares the same centered layout */
        #start-screen, #game-over-screen, #victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
        }
        .hidden {
            display: none !important;
        }

        /* CSS FOR RULES */
        .rules-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
            background: rgba(255,255,255,0.5);
            padding: 15px;
            border-radius: 20px;
        }
        .rule-group h3 {
            margin: 5px 0 10px 0;
            font-size: 22px;
            color: #333;
        }
        .targets-row {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .character-preview {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 70px;
        }
        .character-preview span {
            font-weight: bold;
            font-size: 14px;
            margin-top: 5px;
            color: #555;
        }
        .preview-img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border-width: 4px;
            border-style: solid;
            background: #eee;
        }
        .bomb-border {
            border-color: #ff4444;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.4);
        }
        .target-border {
            border-color: #26c226;
            box-shadow: 0 0 15px rgba(38, 194, 38, 0.4);
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            background-color: #ff69b4;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 105, 180, 0.4);
            transition: transform 0.1s;
            margin-top: 20px;
        }
        button:active {
            transform: scale(0.95);
        }
        /* Screen shake animation for penalty */
        .shake {
            animation: shake 0.5s;
            animation-iteration-count: 1;
        }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
    </style>
</head>
<body id="body">

    <!-- Score UI -->
    <div id="ui-layer">
        <h1>Mom Ninja</h1>
        <p>Score: <span id="score">0</span></p>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 style="font-size: 40px; color: #ff69b4;">Mom Ninja!</h1>
        
        <div class="rules-container">
            <!-- DON'T SLASH -->
            <div class="rule-group">
                <h3 style="color: #d32f2f;">‚ùå ÈÄôÂÄã‰∏çË¶ÅÁ†çÔºåÊúÉÊâ£ÂàÜ ‚ùå</h3>
                <div class="targets-row">
                    <div class="character-preview">
                        <!-- Make sure filename matches JS below -->
                        <img src="mom.jpg" class="preview-img bomb-border"> 
                        <span>Mom</span>
                    </div>
                </div>
            </div>

            <!-- SLASH THESE -->
            <div class="rule-group">
                <h3 style="color: #2e7d32;">‚öîÔ∏è ÈÄô‰∫õÂèØ‰ª•Áõ°ÊÉÖÁ†ç, 20ÂàÜÂ∞±Ë¥è‰∫Ü ‚öîÔ∏è</h3>
                <div class="targets-row">
                    <div class="character-preview">
                        <img src="daniel.jpg" class="preview-img target-border">
                        <span>D</span>
                    </div>
                    <div class="character-preview">
                        <img src="dad.jpg" class="preview-img target-border">
                        <span>S</span>
                    </div>
                    <div class="character-preview">
                        <img src="sis.jpg" class="preview-img target-border">
                        <span>V</span>
                    </div>
                </div>
            </div>
        </div>

        <button id="startBtn">Start Game</button>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen" class="hidden">
        <h1 style="font-size: 50px; color: #ff69b4; margin-bottom: 10px;">üéâ VICTORY! üéâ</h1>
        <h2 style="font-size: 30px; color: #333;">Ë¶™ÊÑõÁöÑÂ®òÔºåÁ•ù‰Ω†ÁîüÊó•Âø´Ê®Ç</h2>
        <p style="font-size: 20px; color: #555;">Best mom</p>
        <div style="font-size: 60px; margin: 20px;">üéÇüéÅüéà</div>
        <button id="restartBtn">Play Again</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const victoryScreen = document.getElementById('victory-screen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const body = document.getElementById('body');

        // --- LOAD IMAGES HERE ---
        // Make sure these files exist in the same folder!
        const meImg = new Image();
        meImg.src = 'daniel.jpg'; 

        const momImg = new Image();
        momImg.src = 'mom.jpg';

        const dadImg = new Image();
        dadImg.src = 'dad.jpg';

        const sisImg = new Image();
        sisImg.src = 'sis.jpg';

        // Game State
        let score = 0;
        let gameRunning = false;
        let lastTime = 0;
        
        // Settings
        const GRAVITY = 0.4; // How fast things fall
        const WINNING_SCORE = 20;
        
        // Arrays
        let fruits = []; // The faces
        let particles = []; // Explosion effects
        let blade = []; // The mouse trail points

        // Mouse/Touch State
        let isDown = false;
        let mouseX = 0;
        let mouseY = 0;

        // Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- INPUT HANDLERS (Mouse & Touch) ---
        function handleStart(x, y) {
            isDown = true;
            mouseX = x;
            mouseY = y;
            blade = []; // Start new cut
            blade.push({x, y});
        }

        function handleMove(x, y) {
            if (!isDown) return;
            mouseX = x;
            mouseY = y;
            blade.push({x, y});
            
            // Keep blade short for performance and visuals
            if (blade.length > 20) blade.shift();
        }

        function handleEnd() {
            isDown = false;
            blade = []; // Clear trail immediately on lift
        }

        // Mouse Events
        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        canvas.addEventListener('mouseup', handleEnd);

        // Touch Events
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        canvas.addEventListener('touchend', handleEnd);


        // --- GAME CLASSES ---

        class Fruit {
            constructor() {
                this.radius = 40;
                // Spawn at bottom
                this.x = Math.random() * (canvas.width - 100) + 50;
                this.y = canvas.height + this.radius;
                
                // Toss Upwards with slight random angle
                this.vx = (Math.random() - 0.5) * 6; // Horizontal drift
                this.vy = -(Math.random() * 8 + 12); // Vertical toss strength (12 to 20)
                
                this.rotation = 0;
                this.rotSpeed = (Math.random() - 0.5) * 0.2;
                
                this.active = true;
                
                // CHARACTER LOGIC
                // 20% Chance it's Mom (BOMB)
                // 80% Chance it's a Target (Me, Dad, or Sis)
                if (Math.random() > 0.8) {
                    this.type = 'mom';
                    this.isBomb = true; 
                } else {
                    this.isBomb = false;
                    // Randomly pick which family member to slash
                    const r = Math.random();
                    if (r < 0.33) {
                        this.type = 'me';
                    } else if (r < 0.66) {
                        this.type = 'dad';
                    } else {
                        this.type = 'sis';
                    }
                }
            }

            update() {
                // Physics
                this.x += this.vx;
                this.y += this.vy;
                this.vy += GRAVITY; // Apply gravity
                this.rotation += this.rotSpeed;

                // Remove if falls off screen
                if (this.y > canvas.height + 100) {
                    this.active = false;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // DRAW BASED ON TYPE
                if (this.type === 'mom') {
                    ctx.drawImage(momImg, -40, -40, 80, 80);
                } else if (this.type === 'me') {
                    ctx.drawImage(meImg, -40, -40, 80, 80);
                } else if (this.type === 'dad') {
                    ctx.drawImage(dadImg, -40, -40, 80, 80);
                } else if (this.type === 'sis') {
                    ctx.drawImage(sisImg, -40, -40, 80, 80);
                }

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 1.0;
                this.color = color;
                this.emoji = Math.random() > 0.5 ? "üíñ" : "‚ú®";
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.03;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.font = "20px Arial";
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        // --- CORE FUNCTIONS ---

        function winGame() {
            gameRunning = false;
            victoryScreen.classList.remove('hidden');
            // Trigger a final confetti explosion for effect
            for(let i=0; i<30; i++) {
                particles.push(new Particle(canvas.width/2, canvas.height/2));
            }
            draw(); // Draw one last frame to show the explosion
        }

        function checkCollisions() {
            if (blade.length < 2) return;

            // Get the latest line segment from the blade
            const p1 = blade[blade.length - 2];
            const p2 = blade[blade.length - 1];

            fruits.forEach(fruit => {
                if (!fruit.active) return;

                // Math: Distance from point (fruit) to line segment (blade)
                const dist = pointToLineDist(fruit.x, fruit.y, p1.x, p1.y, p2.x, p2.y);

                if (dist < fruit.radius) {
                    // HIT!
                    fruit.active = false;
                    
                    if (fruit.isBomb) {
                        // Slashed Mom (BAD)
                        score -= 5;
                        scoreEl.innerText = score;
                        scoreEl.style.color = "red";
                        setTimeout(() => scoreEl.style.color = "#d63384", 500);
                        
                        // Screen Shake
                        body.classList.remove("shake");
                        void body.offsetWidth; // trigger reflow
                        body.classList.add("shake");
                        
                    } else {
                        // Slashed Me/Dad/Sis (GOOD)
                        score++;
                        scoreEl.innerText = score;
                        // Spawn Particles
                        for(let i=0; i<8; i++) {
                            particles.push(new Particle(fruit.x, fruit.y));
                        }
                        
                        // CHECK WIN CONDITION
                        if (score >= WINNING_SCORE) {
                            winGame();
                        }
                    }
                }
            });
        }

        // Helper: Distance from point (px,py) to segment (x1,y1)-(x2,y2)
        function pointToLineDist(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            
            if (len_sq !== 0) param = dot / len_sq;

            let xx, yy;

            if (param < 0) {
                xx = x1; yy = y1;
            } else if (param > 1) {
                xx = x2; yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function draw() {
             // Clear Screen
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Fruits
            for (let i = fruits.length - 1; i >= 0; i--) {
                fruits[i].draw(ctx);
            }
            // Draw Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].draw(ctx);
            }
            // Draw Blade
             if (blade.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                ctx.lineWidth = 8;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.moveTo(blade[0].x, blade[0].y);
                for (let i = 1; i < blade.length; i++) {
                    ctx.lineTo(blade[i].x, blade[i].y);
                }
                ctx.stroke();
            }
        }

        // --- MAIN LOOP ---

        function animate(timestamp) {
            if (!gameRunning) return;
            
            // 1. Spawner
            if (timestamp - lastTime > 1000) { // Approx 1 second
                const count = Math.floor(Math.random() * 2) + 1;
                for(let i=0; i<count; i++) fruits.push(new Fruit());
                lastTime = timestamp;
            }

            // 2. Updates
            for (let i = fruits.length - 1; i >= 0; i--) {
                fruits[i].update();
                if (!fruits[i].active) fruits.splice(i, 1);
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
            
            // 3. Draw Everything
            draw();

            // 4. Collisions
            if (blade.length > 1) checkCollisions();

            // 5. Cleanup Blade
            if (blade.length > 0 && !isDown) {
                blade.shift();
            }

            requestAnimationFrame(animate);
        }

        // --- INIT ---
        startBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            startGame();
        });

        restartBtn.addEventListener('click', () => {
            victoryScreen.classList.add('hidden');
            startGame();
        });

        function startGame() {
            gameRunning = true;
            score = 0;
            scoreEl.innerText = score;
            fruits = [];
            particles = [];
            requestAnimationFrame(animate);
        }

    </script>
</body>
</html>
